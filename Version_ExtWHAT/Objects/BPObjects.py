# -*- coding: utf-8 -*-
"""


@author: mfirat
"""



########################################################################################

class Node:
    def __init__(self,myid,myparent, Left):
         
        self.id = myid
        if self.id == 0:
            self.treedepth = 0
        else:
            self.treedepth = myparent.treedepth + 1
            
        self.parent = myparent
        self.generatedcolumns = [] #These are the columns generated by the column generation during exploration of this node
        
        self.cancelledcolumns = [] # Columns forbiden for being selected (ub=0)
        self.branchedcolumns = [] # Columns forced to be selected (ub=1)
        self.branchedjobmachs= [] # Job-machine assignments to branch
        self.branchedjobtimes= [] # Job-machine assignments to branch
        
        self.Left = Left    
        self.lbvalue = 0
        self.schedulebranched = False
        self.assignbranched = False
        
        self.earlybranch = False
        self.root = int(myparent is None)
        
        self.MasterCompTime = None
        self.ColumnCompTime = []
        self.NodeProperties = None
        
        self.explored = False
        
        
        # properties of the node to use for selection and branching
        self.MPFirstSolArtValue = 0
        self.MPFirstSolIntegers = 0
        self.MPFirstSelectedSchedules = 0
        
        self.MPLastSolInteger = 0 
        self.MPLastSolValue = 0 # lower bound of the master problem if CG is terminated due to optimality 
        self.MPLastSelectedSchedules = 0
        
        self.CGIterations = 0
        
        
        
    def setScheduleBranched(self):
        self.schedulebranched = True
    
    def IsScheduleBranched(self):
        return self.schedulebranched
    
    def setAssignBranched(self):
        self.assignbranched = True
    
    def IsAssignBranched(self):
        return self.assignbranched
    
    
    def SetExplored(self):
        self.explored= True
        
    def IsExplored(self):
        return self.explored
        
        
    def setNodeProperties(self, NodeProperties):
        self.NodeProperties = NodeProperties
        

    def getTreeDepth(self):
        return self.treedepth
    # def ExcludeColumn(self, )
        
    def getID(self):
        return self.id
    
    def getParent(self):
        return self.parent
    
    def getGeneratedColumns(self):
        return self.generatedcolumns
    
    def setLBValue(self,lbval):
         self.lbvalue = lbval
         
    def getLBValue(self):
        return self.lbvalue
    def IsEarlyBranch(self):
        return self.earlybranch
    
     
    def BacktrackNode(self):
        
        for colmn in self.getAddedColumns():
            colmn.ub = 0
        for colmn in self.cancelledcolumns:
            colmn.ub = 1   
        for colmn in self.selected:
            colmn.lb = 0 
        
    def ActivateNode(self):
        
        for colmn in self.getAddedColumns():
            colmn.ub = 1
        for colmn in self.cancelledcolumns:
            colmn.ub = 0   
        for colmn in self.selected:
            colmn.lb = 1 
            
    def EnterNode(self):

        for colmn in self.cancelledcolumns:
            colmn.ub = 0   
        for colmn in self.selected:
            colmn.lb = 1 
        
    def IsRoot(self):
        return self.root
        
   

class Solution:
    
    def __init__(self,myval,mynode,selectedschedules):  
        self.value = myval
        self.node = mynode
        self.schedules = selectedschedules
        
        
    def getSchedules(self):
        return self.schedules
    
    def getObjValue(self):
        return self.value
    
    def getNode(self):
        return self.node
  
    

    
class CGProperties:
    
    def __init__(self, iteration, mastercomptime, pricingcomptime, pricingcomptype, mastersolval, MasterProperties, ColumnsNegRedCost):
        
        
        artvars, artvarSUM, selectedcolumns, totalcolumns = MasterProperties
        
       
        #E MasterProperties = [artvarcounter,artvarSUM, selectedschedules, schedulescounter]
         
         
        self.Iteration = iteration
        
        # master model structure properties
        self.TotalColumns = totalcolumns
       
        
        # computation time statistics
        self.MasterCompTime = mastercomptime
        self.PricingCompTime = pricingcomptime
        self.pricingExact = pricingcomptype 
        self.SelectedColumns = selectedcolumns
        
        
        # master solution statistics
        self.MasterSolVal = mastersolval       
        self.ArtVars = artvars 
        self.artvarSUM = artvarSUM      
     
       

        self.ColumnsNegRedCost = ColumnsNegRedCost
  
        
class NodeProperties:
    
    def __init__(self, node):
        self.idx = None
        self.id = node.id
        self.depth = node.treedepth
        
        self.Explored = 0
        self.Pruned = 0
        self.Fathomed = 0
        
        
        self.FirstRmpSolution = [];
        self.OptimalRmpSolution = None
        self.OptimalRMPObjective = None
        self.TotalSchedules = None
     
        self.CGProperties = []
        self.CGIterations = None
        self.MasterCompTime = None
        self.PricingCompTime = None
                           
        
    def UpdateExplored(self, idx, myNode, CGPropertiesList):
        self.idx = idx
        self.Explored = 1
        self.TotalSchedules = CGPropertiesList[-1].TotalColumns
        self.CGOptimalSolution = CGPropertiesList[-1].SelectedColumns
    
        self.CGProperties = CGPropertiesList
        

        self.CGIterations = CGPropertiesList[-1].Iteration
        self.Objective = CGPropertiesList[-1].MasterSolVal
        self.MasterCompTime = sum([item.MasterCompTime for item in self.CGProperties])
        self.PricingCompTime = sum([item.PricingCompTime for item in self.CGProperties])
        
    def UpdatePruned(self):
        self.Pruned = 1
        
    # def setCGIterations(self):
    #     self.CGIterations = max([item.Iteration for item in self.CGProperties])
        
    # def setMasterCompTime(self):
    #      self.MasterCompTime = sum([item.MasterCompTime for item in self.CGProperties])
        
    # def setPricingCompTime(self):
    #     self.PricingCompTime = sum([item.PricingCompTime for item in self.CGProperties])
    
    
        
        
        
        
    